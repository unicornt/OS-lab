# lab3 实验报告 18307130104 赵文轩

赵文轩 18307130104

[toc]

## 中断发生时 CPU 操作

​	中断发生时，CPU 需要关闭中断，即对 DAIF 寄存器进行 mask 操作，以在 EL1 中屏蔽中断的发生。根据中断的类型，查找中断向量表，跳转到中断向量表中不同的位置。并将中断前的 PSTATE，PC，中断发生原因保存到指定寄存器，同时将 sp 寄存器从 SP_EL0 切换到 SP_EL1，进行栈的切换。

​	在 xv6 操作系统中，vector.S 会获得中断的信息，将所有合法的中断发送到 trapasm.S 中进行处理，trapasm.S 会进行寄存器的保存，即将中断前的寄存器压进内核栈中。完成保存后，trapasm.S 会跳转到 trap.c 的 trap 函数，根据不同的中断类型进行处理。从 trap 返回后，将内核栈中保存的寄存器弹出，进行复原。

## trapframe 的设计

​	trapframe 的设计主要考虑两个方面：1. 需要保存哪些寄存器。2. 需要保存的寄存器该如何排列。

### 需要保存的寄存器

​	在决定 trapframe 需要保存的寄存器之前，需要理清 callee-saved 和 caller-saved 寄存器两个概念。所谓 callee-saved 和 caller-saved 并不是在指出函数调用时，该寄存器需要由谁来保存，而是表明一种该寄存器的使用方式。 callee-saved 寄存器可以用来保存需要长期保存的变量，因为即使是进行了函数调用，被调用的函数也会复原该寄存器的值。caller-saved 寄存器用来暂时存放一些变量，如果想要在函数调用后仍然能够使用，则需要函数调用者自己储存。

​	中断不同于函数调用，中断发生时，进程已经失去了 CPU 的控制权，不能够保存自己仍然想要保留的 caller-saved 寄存器，因此，需要中断处理程序来帮助进程完成这些寄存器的保存。因此，我在 trapframe 的设计中加入了 caller-saved 寄存器，并删除了 callee-saved 寄存器。

​	此外，还需要保存系统寄存器 ELR_EL1，SPSR_EL1，SP_EL0。分别保存了中断发生前的 PSTATE，PC，sp。

>   虽然说理论上确实只需要保存 caller-saved 寄存器，但是我在网上找到许多选择储存所有寄存器的代码（当然也不乏只储存 caller-saved 寄存器的代码），也许为了保险起见应该保存所有寄存器。

### 寄存器排列方式

​	关于寄存器的排列方式主要考虑的是系统寄存器的排布。由于不能直接将系统寄存器亚入栈中，因此需要一个寄存器进行中转。如果系统寄存器在其他寄存器之前保存，那么用作中转的寄存器还需要进行复原。因此，为了方便，将系统寄存器在其他寄存器之后保存。可以发现，这样的设计和 stack frame 的设计也比较相似。

## trapframe 的构建和恢复

### 构建

​	采用 stp 指令将寄存器压入栈中，采用 mrs 指令从系统寄存器取出值到 x10，x11 寄存器中，再用 stp 指令压入栈中。全部压栈完成后，将 sp 赋值给 x0作为函数调用参数，调用 trap。

### 恢复

​	采用 ldp 指令从栈中取出数值。同样系统寄存器需要 x10，x11 作为中转。